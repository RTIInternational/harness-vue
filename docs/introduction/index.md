# About Harness-Vue

## The Problem
When building dashboards for the web, good state management is hard. Developers are often forced to weigh best practices against cost of labor, and incrementally build state and relationships between charts and filters over time - a process often responsible for technical debt. Passing parameters from filters to charts becomes a complex web of parents and children, often leading to the use of state management libraries such as vuex or Pinia. Writing state, getters, actions and mutations for every filter and every chart in a multi-page dashboard is a time-consuming process, and mapping this state to each component adds many lines of boilerplate code as each filter and chart needs to find its place in the store(s).

## Why Harness-Vue

Harness-Vue accelerates the development of web dashboards by automating the processes outlined above. Using Harness-Vue, developers create page definitions as Javascript classes with an expected format that are passed along to the core library. The Harness-Vue plugin takes these page definitions and uses them to generate Pinia stores, each of which is populated with state, getters and actions for the defined charts and filters as well as a robust API for interaction with and between them. The Harness-Vue stores created by the plugin provide developers with the following advantages:

### Time Savings, Tests, Documentation
Using Harness-Vue saves a significant amount of time for developers in three ways: 
* Writing a harness page definition is faster than writing the output provided by the plugin, enabling huge cost savings in early stages of the project as well as during iterative development as page definitions are revised and expanded
* The Harness-Vue stores are thoroughly tested with [vitest](https://vitest.dev/), and validated by the plugin in development, allowing for developer peace of mind in not having to write extensive tests for each of their page definitions
* All Harness-Vue API interactions are documented in these Vitepress docs and the plugin itself is open-source, allowing for even easier DX when using a Harness-Vue application


### Use Across Teams and Collaboration
For teams that manage multiple web dashboards and/or have multiple dashboards, using the Harness-Vue plugin allows for greater cohesion and less context switching between projects given the like structure generated by the plugin. This also allows for greater code re-use between projects, as components referring to Harness-Vue API calls can be more easily ported between applications.


### Separation of Concerns
The Harness-Vue lifecycle and `loadData()` functionality, while opinionated, takes the responsibility of data management (retrieving data from flat files or API calls asynchronously, applying filters to charts, formatting structured data for data visualization libraries) out of your components and into plain Javascript. This separation of concerns reduces complexity in components and enables developers to differentiate between data and display, leveraging Vue and Pinia's inbuilt reactivity to automate the underpinnings.

### More Reusable Components
Using the Harness-Vue API functions, a component can expect to be contextualized to a page and chart/filter anonymously. This allows for greater component reuse with less boilerplate code in an application.

For example, imagine an application that has two pages - one called `population` and one called `environment`. Each page has a number of filters and charts, but both pages have a simple timeseries line chart. On the `population` page, this chart is called `populationOverTime`, but on the `environment` page, it is called `temperatureOverTime`. Using Harness-Vue, each page is given a Pinia store, and each chart has a number of functions for getting at the chart data. In a normal application, one might have to write two components, one for each chart, each of which retrieves data from the correct endpoint, formats it for a timeseries linechart, then makes it available for the chart. Using Harness-Vue, a developer can write a single component that takes the chart key as a prop and uses API functions like `getChartData(chartKey)` as well as the global mixin to work regardless of page or chart.
